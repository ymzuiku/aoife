# 无生命周期

请原谅我，这篇文章需要使用 React 的相关代码举例，因为 aoife 中完全没有生命周期的概念。若您没有使用过 React 或 Vue，没有生命周期的概念，可以直接跳过此章节；因为此章节的目的是为了说服长期使用生命周期概念的开发者离开生命周期。

aoife 并不是跨平台方案，它是专注浏览器的原生 JS 方案，我们接下来的篇幅都是建立在此基础上的。

aoife 一直强调一个概念，在浏览器中，99%的场景不需要生命周期，因为 DOM 对象已经帮我们管理了最关键的状态。

放弃了生命周期我们会发现我们已经解决了组件的绝大部分复杂度。

React 随着版本的更新，一直在移除一些生命周期，并且在 Hooks 方案中，更是使用 useEffect 去描述了许多历史生命周期。其实 Hooks 本身也是弱化生命周期的概念，但是大家已在 ReactComponent 类的生命周期基础上先入为主，所以才会在 Hooks 刚推出的时候需要描述 Hooks 对应历史生命周期的方案。

> aoife 其实完全放弃了任何一个生命周期钩子。

## 模拟生命周期

我们首先回顾一下 React 为什么需要生命周期。

在 React 中，我们一个组件在插入到 DOM 之前，我们可能需要处理一些事情

### 渲染之前

这是一个 React 的例子

```jsx
// React Class 例子
class Welcome extends React.Component {
  constructor(props) {
    super(props);
    console.log("do a");
  }
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}

// React Hooks 例子
function Welcome({ name }) {
  // 因为组件若更新，log 不应该重复执行，所以需要放到 useLayoutEffect 中
  useLayoutEffect(() => {
    console.log("do a");
  }, []);
  return <h1>Hello, {props}</h1>;
}
```

而在 aoife，他们简化为傻瓜模式：

```jsx
function Welcome({ name }) {
  // Welcome 内部有更新，并不会导致整个函数重新执行，所以可以直接写在函数中
  console.log("do a");
  console.log("do b");
  return <h1>Hello, {props}</h1>;
}
```

### 已渲染

在 React 中，当元素渲染结束之后，我们需要获取元素，这时候需要生命周期 componentDidMount。

这是一个 React componentDidMount 的例子, 为了减少不必要的代码，我们这里不再同时描述 hooks 版本。

```jsx
// React Class 例子
class Welcome extends React.Component {
  refH1 = null;
  componentDidMount() {
    console.log(this.refH1);
  }
  render() {
    return <h1 ref={(r) => (this.refH1 = r)}>Hello, {this.props.name}</h1>;
  }
}
```

在 aoife 中，由于没虚拟 DOM，我们不需要等待渲染后才能获取元素的实例

```jsx
// Aoife 例子
function Welcome({ name }) {
  const h1 = <h1>Hello, {this.props.name}</h1>;
  // 已经有了 h1 的实例，但是此时 h1 还未插入到 DOM 中
  console.log(h1);
  return h1;
}
```

因为 aoife 并没有 生命周期，所以我们没有元素已成功插入 DOM 中的回调用, aoife 不愿意为此情况影响 aoife 保持简单的原则， 建议规避此类设计。

若遇到有些场景我们无法规避此情况，如需要获取一些元素渲染后的属性，为此 aoife 仅提供了一个轮询的方案：`waitAppend`。

绝大部分场景，`waitAppend` 都会在一个宏任务之后执行并结束，并没有什么性能损失。

有一种例外的情况：若您在组件实例之后将其挂起，等其他时机再插入 DOM 中渲染，waitAppend 会轮询多次，并且可能失败。

```jsx
// Aoife 例子
function Welcome({ name }) {
  const h1 = <h1>Hello, {this.props.name}</h1>;
  // 等待 h1 插入到页面中进行回调，若 500ms还未渲染，则放弃回调
  aoife.waitAppend(h1).then(() => {
    console.log(h1.height);
  });
  return h1;
}
```

### 组件被移除时取消订阅

在 React 中，若您订阅了一些事件，需要在组件被删除前同时移除相关事件，我们会使用 componentWillUnmount 生命周期, 于此同时，通常都会在已渲染之后进行注册。

```jsx
// React class 例子
class Welcome extends React.Component {
  doSometing: () => {
    console.log('do');
  };
  componentDidMount() {
    this.unListen = listenSometing(this.doSometing);
  }
  componentWillUnmount() {
    this.unListen()
  }
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

在 aoife 中，可以利用 aoife 自身的事件派发机制，我们不需要取消订阅，组件销毁后订阅也不会继续发生。

```jsx
// Aoife 例子
function Welcome({ name }) {
  return (
    <h1
      watch={() => {
        console.log("do");
      }}
    >
      Hello, {name}
    </h1>
  );
}

// 派发任务，若组件销毁，组件内部自然不会接收到订阅
aoife.next("[watch]");
```

合理利用 aoife 自身的事件派发，可以规避掉大部分生命周期的使用场景。
