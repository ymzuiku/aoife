## 不期之遇

首先，您可以跳过此章节，你只需要记住 aoife 中不需要也不存在生命周期钩子即可。

本章节并不像其他章节一样简洁，就好像您在旅途中遇到了另一位满脸忧愁的旅者，他向你诉说着他的困惑，这本并不是轻松旅途的一部分。

当然您要愿意听他唠叨，或许也有其他收获。

## 无生命周期

请原谅我，这篇文章篇幅很长，并且使用了 React 的代码和 aoife 做对比举例，有了对比才能更好的理解 aoife 的策略。

此章节的目的是为了说服长期使用生命周期概念的开发者离开生命周期。若您没有使用过 React 或 Vue，没有生命周期的概念，可以直接跳过此章节。

aoife 一直强调一个概念，在浏览器中，99%的场景不需要生命周期钩子，因为 DOM 对象已经帮我们管理了最关键的状态。

> aoife 并不是跨平台方案，它是专注浏览器的原生 JS 方案，我们接下来的篇幅都是建立在此基础上的。

放弃了生命周期的同时，我们也解决了前端框架的绝大部分复杂度。

> React 随着版本的更新，一直在合并、移除一些生命周期. 其实 React Hooks 本身也是弱化生命周期的概念，但是大家已在 ReactComponent 类的生命周期基础上先入为主，所以才会在 Hooks 刚推出的时候需要描述 Hooks 对应历史生命周期的方案。

> 而 aoife 完全放弃了所有生命周期钩子。

## 关键生命周期的对比

不管其他框架的生命周期 API 如何命名，一般来说生命周期最重要的是以下 4 个阶段：

- 组件渲染之前
- 组件已渲染
- 组件更新时
- 组件移除时

借用 React 的一些代码，我们一步步对照在没有生命周期钩子时，aoife 是如何做以上几个行为的。

### 组件渲染之前

在 React 中，我们一个组件在插入到 DOM 之前，我们可能需要处理一些事情

这是一个 React 的例子

```jsx
// React Class 例子
class Welcome extends React.Component {
  constructor(props) {
    super(props);
    console.log("do a");
  }
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}

// React Hooks 例子
function Welcome({ name }) {
  // 因为组件若更新，log 不应该重复执行，所以需要放到 useLayoutEffect 中
  useLayoutEffect(() => {
    console.log("do a");
  }, []);
  return <h1>Hello, {props}</h1>;
}
```

而在 aoife，他们简化为傻瓜模式：

```jsx
// aoife 例子
function Welcome({ name }) {
  // Welcome 内部有更新，并不会导致整个函数重新执行，所以可以直接写在函数中
  console.log("do a");
  console.log("do b");
  return <h1>Hello, {props}</h1>;
}
```

### 组件已渲染

在 React 中，当元素渲染结束之后，我们需要获取元素，这时候需要生命周期 componentDidMount。

这是一个 React componentDidMount 的例子, 为了减少不必要的代码，我们这里不再同时描述 hooks 版本。

```jsx
// React Class 例子
class Welcome extends React.Component {
  refH1 = null;
  componentDidMount() {
    console.log(this.refH1);
  }
  render() {
    return <h1 ref={(r) => (this.refH1 = r)}>Hello, {this.props.name}</h1>;
  }
}
```

在 aoife 中，由于没虚拟 DOM，我们不需要等待渲染后才能获取元素的实例

```jsx
// aoife 例子
function Welcome({ name }) {
  const h1 = <h1>Hello, {this.props.name}</h1>;
  // 已经有了 h1 的实例，但是此时 h1 还未插入到 DOM 中
  console.log(h1);
  return h1;
}
```

因为 aoife 并没有 生命周期，所以我们没有元素已成功插入 DOM 中的回调用, aoife 不愿意为此情况影响 aoife 保持简单的原则， 建议规避此类设计。

若遇到有些场景我们无法规避此情况，如需要获取一些元素渲染后的属性，为此 aoife 仅提供了一个轮询的方案：`waitAppend`。

绝大部分场景，`waitAppend` 都会在一个宏任务之后执行并结束，只要您不是大规模的使用，并没有多少性能损失。

有一种例外的情况：若您在组件实例之后将其挂起，等其他时机再插入 DOM 中渲染，waitAppend 会轮询多次，并且可能失败。

```jsx
// aoife 例子
function Welcome({ name }) {
  const h1 = <h1>Hello, {this.props.name}</h1>;
  // 等待 h1 插入到页面中进行回调，若 500ms还未渲染，则放弃回调
  aoife.waitAppend(h1).then(() => {
    console.log(h1.height);
  });
  return h1;
}
```

### 组件更新时

aoife 的组件更新相对于 React 简单又高效，并且心智负担极低。

React 的组件更新是生命周期中造成性能问题的关键因素。

React 中组件更新会重新执行 render 方法，也就同时更新了子组件的 render 方法，以此类推。

所以 React 中性能的瓶颈往往就会出现再次，我们需要花费很多心思去拦截不必要的更新；为此，React 建议引入 immutable 等其他概念，这里不一一展开。

并且 React 推荐所有用到的函数 `(如下文的 handleOnClick)` 不应该直接写在 JSX 上，不然组件更新会重新创建函数

```jsx
// React Class 例子
class Welcome extends React.Component {
  name = "foo";
  handleOnClick = () => {
    console.log("我点击了");
    this.setState({ name: "bar" });
  };
  render() {
    console.log("我更新了");
    return <h1 onClick={this.handleOnClick}>Hello, {this.name}</h1>;
  }
}
```

React Hook 中, 会重新执行整个 Function；这导致组件中要实现一些对象会更复杂，你为此需要学习 React Hooks 的专有概念。

```jsx
// React Hooks 例子
function Welcom() {
  // 整个函数会重新执行，所以 name 会重新创建，若需要缓存 name 需要使用 useState 或 useRef
  const name = "foo";
  // 使用 useCallback 包裹，减少组件更新时 handleOnClick 重新创建的开销
  const handleOnClick = React.useCallback(() => {
    setName("bar");
    console.log("我点击了");
  });
  return <h1 onClick={handleOnClick}>Hello, {name}</h1>;
}
```

在 aoife 中，一切显得那么自然, 组件不管如何更新，单个组件实例，函数只会执行一次。我们可以像使用普通函数一样使用 aoife 函数.

```jsx
// aoife 例子
function Welcome() {
  // 组件更新不会导致 name 重新创建
  const name = "foo";

  // 组件更新不会导致 JSX 重新解析，JSX中直接声明函数，也不会有性能问题；当然为了更易阅读，还是建议将 onclick 方法提前声明
  return (
    <h1
      onclick={() => {
        console.log("我点击了");
        name = "bar";
        // 仅仅更新 ()=>name 的值，其他一切都是静态的
        aoife.next();
      }}
    >
      Hello, {() => name}
    </h1>
  );
}
```

当然为了更易阅读，还是建议将 onclick 方法提前声明：

```jsx
// aoife 例子
function Welcome() {
  let name = "foo";

  // 直接声明，不需要使用类似 useCallback 包裹
  const handleOnClick = () => {
    console.log("我点击了");
    name = "bar";
    aoife.next();
  };

  return <h1 onclick={handleOnClick}>Hello, {() => name}</h1>;
}
```

### 组件移除时

在 React 中，若您订阅了一些事件，需要在组件被删除前同时移除相关事件，我们会使用 componentWillUnmount 生命周期, 于此同时，通常都会在已渲染之后进行注册。

```jsx
// React class 例子
class Welcome extends React.Component {
  doSometing: () => {
    console.log('do');
  };
  componentDidMount() {
    this.unListen = listenSometing(this.doSometing);
  }
  componentWillUnmount() {
    this.unListen()
  }
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

在 aoife 中，可以利用 aoife 自身的事件派发机制，我们不需要取消订阅，组件销毁后订阅也不会继续发生。

```jsx
// aoife 例子
function Welcome({ name }) {
  return (
    <h1
      watch={() => {
        console.log("do");
      }}
    >
      Hello, {name}
    </h1>
  );
}

// 派发任务，若组件销毁，组件内部自然不会接收到订阅
aoife.next("[watch]");
```

合理利用 aoife 自身的事件派发，可以规避掉大部分生命周期的使用场景。

### 唠叨一句

从本章节是整个 aoife 文档最长篇幅的一章，滑稽的是它仅仅是为了说明 aoife 没有生命周期的概念；这也变相说明生命周期带来的复杂度比得到的特性更多。
